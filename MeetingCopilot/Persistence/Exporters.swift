//
//  Exporters.swift
//  MeetingCopilot
//
//  Export meeting data to various formats
//

import Foundation
import OSLog

private let logger = Logger(subsystem: "com.jeramo.meetingman", category: "persistence")

// MARK: - Markdown Exporter

/// Export meeting as Markdown
public struct MarkdownExporter {

    /// Render meeting to Markdown string
    public static func render(meeting: Meeting, summary: SummaryResult?) -> String {
        logger.debug("Rendering Markdown: \(meeting.transcriptChunks.count) chunks, \(meeting.decisions.count) decisions")

        var md = ""

        // Header
        md += "# \(meeting.title)\n\n"

        // Metadata
        md += "**Date:** \(meeting.startedAt.formatted(date: .long, time: .shortened))\n\n"

        if let endedAt = meeting.endedAt {
            let duration = endedAt.timeIntervalSince(meeting.startedAt)
            md += "**Duration:** \(formatDuration(duration))\n\n"
        }

        if !meeting.attendees.isEmpty {
            md += "**Attendees:** \(meeting.attendees.map(\.name).joined(separator: ", "))\n\n"
        }

        md += "---\n\n"

        // Summary
        if let summary = summary, !summary.bullets.isEmpty {
            md += "## Summary\n\n"
            for bullet in summary.bullets {
                md += "- \(bullet)\n"
            }
            md += "\n"
        }

        // Decisions
        if let summary = summary, !summary.decisions.isEmpty {
            md += "## Decisions\n\n"
            for decision in summary.decisions {
                md += "- \(decision)\n"
            }
            md += "\n"
        } else if !meeting.decisions.isEmpty {
            md += "## Decisions\n\n"
            for decision in meeting.decisions {
                md += "- \(decision.text)"
                if let owner = decision.owner {
                    md += " (Owner: \(owner))"
                }
                md += "\n"
            }
            md += "\n"
        }

        // Action Items
        if let summary = summary, !summary.actionItems.isEmpty {
            md += "## Action Items\n\n"
            for item in summary.actionItems {
                md += "- [ ] \(item)\n"
            }
            md += "\n"
        }

        // Full Transcript
        if !meeting.transcriptChunks.isEmpty {
            md += "## Transcript\n\n"
            let fullTranscript = meeting.fullTranscript
            if fullTranscript.isEmpty {
                logger.warning("Meeting has transcript chunks but fullTranscript is empty")
                md += "*No transcript content available*\n"
            } else {
                md += fullTranscript
                md += "\n"
            }
        } else {
            logger.warning("Meeting has no transcript chunks")
            md += "## Transcript\n\n*No transcript content available*\n"
        }

        // Footer
        md += "\n---\n"
        md += "*Generated by Meeting Copilot on \(Date().formatted(date: .long, time: .shortened))*\n"

        return md
    }

    /// Export to file
    public static func export(meeting: Meeting, summary: SummaryResult?, to directory: URL) throws -> URL {
        let markdown = render(meeting: meeting, summary: summary)

        let filename = sanitizeFilename(meeting.title) + "_" + meeting.startedAt.formatted(date: .numeric, time: .omitted).replacingOccurrences(of: "/", with: "-") + ".md"
        let fileURL = directory.appendingPathComponent(filename)

        do {
            try markdown.write(to: fileURL, atomically: true, encoding: .utf8)
            logger.info("Exported Markdown to \(fileURL.lastPathComponent)")
            return fileURL
        } catch {
            logger.error("Failed to write Markdown: \(error.localizedDescription)")
            throw ExportError.fileWriteFailed
        }
    }

    private static func formatDuration(_ interval: TimeInterval) -> String {
        let hours = Int(interval) / 3600
        let minutes = (Int(interval) % 3600) / 60

        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }

    fileprivate static func sanitizeFilename(_ name: String) -> String {
        let invalidChars = CharacterSet(charactersIn: ":/\\?%*|\"<>")
        return name.components(separatedBy: invalidChars).joined(separator: "_")
    }
}

// MARK: - JSON Exporter

/// Export meeting as JSON
public struct JSONExporter {

    /// Export meeting to JSON
    public static func export(meeting: Meeting, summary: SummaryResult?, to directory: URL) throws -> URL {
        logger.debug("Exporting JSON: \(meeting.transcriptChunks.count) chunks, \(meeting.decisions.count) decisions")

        let payload = MeetingExport(meeting: meeting, summary: summary)

        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
        encoder.dateEncodingStrategy = .iso8601

        do {
            let data = try encoder.encode(payload)

            let filename = MarkdownExporter.sanitizeFilename(meeting.title) + "_" + meeting.startedAt.formatted(date: .numeric, time: .omitted).replacingOccurrences(of: "/", with: "-") + ".json"
            let fileURL = directory.appendingPathComponent(filename)

            try data.write(to: fileURL)

            logger.info("Exported JSON to \(fileURL.lastPathComponent)")
            return fileURL
        } catch {
            logger.error("Failed to export JSON: \(error.localizedDescription)")
            throw ExportError.encodingFailed
        }
    }
}

// MARK: - Export DTO

private struct MeetingExport: Codable {
    let id: UUID
    let title: String
    let startedAt: Date
    let endedAt: Date?
    let duration: TimeInterval?
    let attendees: [PersonRef]
    let transcript: String
    let summary: SummaryResult?
    let decisions: [DecisionDTO]

    init(meeting: Meeting, summary: SummaryResult?) {
        self.id = meeting.id
        self.title = meeting.title
        self.startedAt = meeting.startedAt
        self.endedAt = meeting.endedAt
        self.duration = meeting.duration
        self.attendees = meeting.attendees
        self.transcript = meeting.fullTranscript
        self.summary = summary
        self.decisions = meeting.decisions.map { DecisionDTO(id: $0.id, text: $0.text, owner: $0.owner, timestamp: $0.timestamp) }
    }
}

private struct DecisionDTO: Codable {
    let id: UUID
    let text: String
    let owner: String?
    let timestamp: Date
}
